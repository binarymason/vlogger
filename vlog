#!/usr/bin/env bash

set -e

epoch=$(date +"%s")
ts=$(date +"%Y%m%d" -d "@$epoch")
outdir=${HOME}/vlog/${ts}
clocktime=$(date +"%H%M" -d "@$epoch")
out="${clocktime}_${epoch}"
mpg_file="$outdir/$out.mpeg"
meta_file="$outdir/$out.md"
audio_file=out.wav

info() {
  echo "+ $*"
}

get_weather() {
  curl -s wttr.in?format=3
}

get_duration() {
  ffprobe -i "$mpg_file" -show_format -v quiet | sed -n 's/duration=//p'
}


get_transcript() {
  ffmpeg -loglevel error -i "$mpg_file" -acodec pcm_s16le -ac 1 -ar 16000 "$audio_file" -y
  deepspeech --model models/output_graph.pbmm --alphabet models/alphabet.txt --lm models/lm.binary --trie models/trie --audio "$audio_file" 2>/dev/null
  rm "$audio_file"
}


record_video() {
  info "recording: $ts @$clocktime [press q to stop]"
  mkdir -p "$outdir"

  # arguments
  # -f input (audio or video)
  # -i input device
  # -r frame rate
  # -q:v video quality. (reasonable range 2-5) lower the number, the higher the quality
  ffmpeg -loglevel error -f alsa -i plughw:CARD=Snowball,DEV=0  -f video4linux2 -i /dev/video0 -r 60 -q:v 2 "$mpg_file"
}

playback() {
  info "starting playback [press q to stop]"
  ffplay -loglevel error -autoexit "$mpg_file"
}

process() {
  info "processing..."
  duration=$(get_duration)
  info "getting the weather..."
  weather=$(get_weather)
  info "transcribing..."
  transcript=$(get_transcript)
  wait
  echo -n "Add space delimited emotions then Press ENTER (leave blank to skip): "
  read -r emotion
  emotion=$(echo "$emotion" | tr ' ' ',')
  {
    echo "---"
    echo
    echo "duration: $duration"

    [[ ! -z "$emotion" ]] && echo "emotion: $emotion"
    echo "timestamp: $epoch"
    echo "weather: '$weather'"
    echo "---"
    echo "$transcript"
    echo
  } >> "$meta_file"

  echo "video saved to: $mpg_file"
  echo "meta saved to: $meta_file"
  cat "$meta_file"
}

record_video
playback & # fork so processing happens in background during playback
process

